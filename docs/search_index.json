[
["preface.html", "GEOG 473/673 Open-sourced Environmental Computing 1 Preface 1.1 Syllabus 1.2 Agenda", " GEOG 473/673 Open-sourced Environmental Computing James Simkins 2020-08-28 1 Preface Phase 1: Environmental Computing with R - 9/1/2020 to 10/1/2019 – 1cr Phase 2: Spatial Computing with Python – 10/2/2020 to 12/10/2020 – 2cr The objective of GEOG 473/673 Open-sourced Environmental Computing is for advanced undergraduate and graduate students to gain practical experience with R &amp; Python, two industry-leading open-sourced programming languages. Both of these languages are used to assemble, read, and manage large geospatial and environmental datasets by academics, government scientists, and private industry. Each of these programming languages offer a plethora of free packages that allow a user to work with big spatial data in an analytical manner without paying a dime. The demand for students knowledgeable in R &amp; Python is continuing to grow. It’s important to note that this is an Introduction to R (or Python), NOT an introduction to programming. This challenging, fast-paced course is intended for students that already have at least basic programming experience. 1.1 Syllabus https://github.com/jsimkins2/geog473-673/blob/master/documents/fall_geog473_673_syllabus.pdf 1.2 Agenda This course is split into 2 phases - R and Python. For the R phase, this will be our schedule. Week Focus 1 An Introduction to R 2 Scientific R Scripts 3 Time Series Analysis with DEOS data 4 Raster Analysis with Oceanography &amp; Global Tree Cover data 5 Resampling and Reprojecting Rasters with climatological temperature data "],
["getting-started-with-r.html", "2 Getting Started with R 2.1 Why is there such a buzz around R? 2.2 Reasons to love R 2.3 Downloading Guide 2.4 Rstudio 2.5 Download Course Datasets 2.6 Video Examples 2.7 Getting familiar with RStudio 2.8 Open RStudio 2.9 R Studio Layout", " 2 Getting Started with R 2.1 Why is there such a buzz around R? R is an open-source programming language used for data science, statistics, and data visualization. R is currently ranked as the 7th most popular language in the world. Since R is open-source, anyone can contribute to or use R packages that contain pre-built functions/operations. This greatly accelerates our ability to share and collaborate. The first thing you need to do to get started with R is to install it on your computer. R works on pretty much every platform available, including the widely available Windows, Mac OS X, and Linux systems. R takes up very little space on your machine, despite it’s pleathora of data-science capabilities. All of these downloads are 100% free and trusted sources. 2.2 Reasons to love R Attribute Reason Speed R is FAST. It can number crunch magnitudes faster than Microsoft Excel, for example. Capacity R can handle millions of data records. Large datasets that crash in Microsoft Excel or ArcGIS won’t crash in R. Risk Reduction After writing a single R Script, the process of your data science routine is auditable and reproducible within milliseconds. We can write 1 script and make alterations as we see fit. We don’t have to replicate a process of pointing and clicking in Microsoft Excel or ArcGIS. For example, if you are working with a dataset that multiple people are using, you can load this dataset in R and perform the tasks that you need without making any changes to the original dataset. Visualizations R is capable to create high quality visualizations and also has the capacity to create interactive visualizations that can easiliy be shared. Plots or images can easily be exported to PNG, JPEG, or even web-based interactive dashboards that can be hosted on a webpage Collaboration R script sharing is safe and easy. As mentioned above, a team using the same data input file but performing different tasks on it can do so without editing the data input file for everyone else. Data output can also be shared without the concern of a colleague editing the file output. RStudio connect or Github are also popular free track all changes that take place between R script files. Price R is completely free! Yes…every bit of it! 2.3 Downloading Guide Navigate to the R website: https://cloud.r-project.org/ Click Download for your Operating System (Windows, Mac OSx, or Linux - if you don’t have a MacBook, then you’re using Windows most likely) Click the most recent R version to download. Install the downloaded application as you would with any other application on your computer. 2.4 Rstudio While R is the language, RStudio is the application we use to run R. Technically speaking, RStudio is an integrated development environment for R. RStudio makes coding in R easier by highlighting syntax, autocompleting symbols and names, and visualizing our R environment. These aspects are explained in further detail in the R Coding Fundamentals section. For now, let’s download RStudio. Navigate to the RStudio Website: http://www.rstudio.com/download Click Download under RStudio Desktop Free This website detects your operating system, allowing you to just click download again. Note that if it doesn’t automatically detect just select the download next to your operating system below this Note that you may be asked to install command line developer tools if you’re using a Mac - select Yes. Install the downloaded application as you normally would on your computer. 2.5 Download Course Datasets Navigate to the database - https://github.com/jsimkins2/geog473-673/tree/master/datasets Click on Code - then click download as zip 2.6 Video Examples If you want to watch a step-by-step tutorial on how to install R for Mac or Windows, you can watch these videos courtest of Dr. Roger Peng Installing R on Windows Installing R on the Mac Installing RStudio 2.7 Getting familiar with RStudio By now you’ve downloaded R and RStudio and you’re probably wondering, why do I need to download both? R is that programming language that is running on your computer. RStudio is what we call an Indegrated Development Environment (IDE) - this is a technical term for a pretty application that’s all dressed up on the surface but underneath is really crunching some numbers (using R) at serious speeds. RStudio is the application we’ll be using. Let’s open RStudio and get familiar with it. 2.8 Open RStudio Navigate to your applications folder on your computer. Launch RStudio. When you open it for the first time, you should see this. This is RStudio. When you open it for the first time, we’ll need to open a new RScript to begin coding. Open new R Script To open a new R Script, we select the blankpage with green plus icon and select R Script from the menu. This opens up the new R script and we can begin coding in R. Now that we have the R Script open, you’ll notice 4 quadrants. Let’s run through what those quadrants are. 2.9 R Studio Layout Now let’s describe what’s going on here in a little more detail. R Script - This is your canvas. This is where we write and edit our code. A lot of trial and error goes on here. R Console - This is where you run your code. When we talk about running code, we mean we’re telling R to execute the code we’ve written in the R Script. R Console is the place inside RStudio where we are using the R programming language. Variable Environment - This area keeps track of your variables, data tables, filenames, etc. Anything that you run in R that has a name will be stored here. Imagine the Variable Environment to be your closet - every time you make/buy a new sweater, the sweater goes in the closet. We can select data tables to view from this list here. Files/Plots/Help - In this quadrant, we can toggle through files on our computer (we can view where your files are stored), view plots/visualizations that we’re creating in R (whenever you create a plot in R it is output here first), search for help and descriptions of R functions (there’s descriptions on every function you’ll use in R - they can all be loaded here in the help tab), and more. "],
["definitions-rules.html", "3 Definitions &amp; Rules 3.1 Important R Programming Definitions 3.2 Rules 3.3 General Recommendations", " 3 Definitions &amp; Rules This is a reference guide to look back on when you’re stuck. These definitions and rules are not expected to be understood right now but it’s important you know you can look back on this as a quick-reference. 3.1 Important R Programming Definitions Read through these now to get familiar and refer back to these whenever you need a refresher. You’re not expected to have these memorized or even understood at this moment. These will make more sense as we progress through the course. Coding Name Example Definition syntax R code the nomenclature and structure of a programming language debugging Failed R run debugging involves fixing R code that is written incorrectly and doesn’t run variable names Variables are used to store data, whose value can be changed according to our need. Variables can be declared using &lt;- (tradiational way) or by = (conventional way) package library(ggplot2) A collection of functions prewritten in R function print() A function is a set of statements organized together to perform a specific task. R has a set of preloaded functions that are part of the base package. If a function cannot be found as part of the base package, the function has likely already been built under another package that needs to be loaded in. Functions can be identified due to their enclosing parantheses () arguments read.csv(file = &quot;datasets/tv_shows.csv&quot;, header = FALSE) Components of a function that are separated by commas and declared using the = sign. Arguments in this example are file = and header = index tv_data[3,55] The position of data within a data frame, matrix, list, vector, etc. In R, data is indexed as [row,column] and indexing is done via brackets [] loop for (n in names){print(n)} Repeats a task for a specified number of times. Saves a programmer from repeating codelines with different parameters. logical TRUE, FALSE TRUE and FALSE logical operators are declared using all caps arithmetic operators +,-,*,/,^ Math operators used for addition, subtraction, multiplication, division, exponent, respectively. comparison operators ==, &lt;, &gt;, &lt;=, &gt;=, != Is equal to, less than, greater than, less than or equal to, greater than or equal to, is NOT equal to, respectively and/or operators &amp;, | AND, OR string a_string = &quot;anythign within quotes, single or double&quot; Any value written within a pair of single quote or double quotes in R is treated as a string. numeric 1 Any number - integer, float, etc. vector as.vector(x = c(1,2,3,4)) Vectors are the most basic R data objects and there are six types of atomic vectors. They are logical, integer, double, complex, character and raw. lists list('Peter', 'Sarah', 'Tom', 'Helen') Lists are the R objects which contain elements of different types like − numbers, strings, vectors and another list inside it matrix matrix(c(1:5), nrow = 3, byrow = TRUE) Matrices are the R objects in which the elements are arranged in a two-dimensional rectangular layout. array array(data = c(1,2,3)) Arrays are the R data objects which can store data in more than two dimensions. For example − If we create an array of dimension (1, 2, 3) then it creates 3 rectangular matrices each with 1 rows and 2 columns. Arrays can store only one data type. data frame data.frame(tv_data) R version of Excel Spreadsheet. A data frame is a table or a two-dimensional array-like structure in which each column contains values of one variable and each row contains one set of values from each column. factor factor() Factors are the data objects which are used to categorize the data and store it as levels. They can store both strings and integers. They are useful in the columns which have a limited number of unique values. Like “Male,”Female&quot; and True, False etc. They are useful in data analysis for statistical modeling. help help(read.csv) Default helper function in R. Opens up documentation on a particular function in the lower right quadrant of R. class class(tv_data) Tells us what R is recognizing something as concatenate (c) c(“a”, “b”, “c”) A quick utility for concatenating strings together filepath “/Users/james/Downloads/” The location on your computer where a file is stored. A filepath with a leading slash (akak “/” ) is also referred to as root. Root is the furthest back you can go on your computer. Think of a filepath like this - “/Earth/UnitedStates/Delaware/Newark/” Additional examples can be found here 3.2 Rules Variable names must be assigned. names_list &lt;- list(&#39;Peter&#39;, &#39;Sarah&#39;, &#39;Tom&#39;, &#39;Helen&#39;) 3.2 is the Comment Operator - anything on the same line of the # comment operator will not be run by R. # comments can be above names_list &lt;- list(&#39;Peter&#39;, &#39;Sarah&#39;, &#39;Tom&#39;, &#39;Helen&#39;) # comments can be outside ## comments can be anywhere. Parantheses (), Brackets [], Curly brackets {}, Quotations &quot;&quot; must be used in pairs names_list = list(&#39;Peter&#39;, &#39;Sarah&#39;, &#39;Tom&#39;, &#39;Helen&#39;) for (n in names_list){ print(n) } If you don’t have a package, you must install that package. (After you install once, you don’t need to install again.) install.packages(&#39;ggplot2&#39;) Packages MUST be loaded for each R session. library(ggplot2) Variable names cannot replicate function/package names. 3.3 General Recommendations Comment, comment, comment. A comment is a brief note on what you were doing when you wrote a line of code. For example, if you write some R code that edits part of a dataframe (R’s version of an Excel Spreadsheet), comment what you were thinking here and why you did it this way. Once you become comfortable coding in R, you’ll be able to churn out new R scripts at a faster rate. It’s very important that you comment on what you’re doing at each step in the script so if you need to look back on something you wrote you can reference what you were doing there. A comment in R is declared using the pound symbol (#). Keep raw data raw. An advantage of R is being able to read in an original spreadsheet and output a new spreadsheet as a separate file. In other words, when you read in a dataset (for example, tv_shows.csv) and make changes to this file, do not save it was tv_shows.csv - thus overwriting the file. Instead, name it something like tv_shows_edited.csv. Also, notice how we use underscores (_) in between words of a filename - this is good practice that should be replicated (spaces are bad, see 4) When in doubt, Google your R question - look for StackOverflow links. StackOverflow is a web-forum where programmers can post questions for help. This is an incredible tool that even advanced programmers and developers use daily. There are other helpful forums out there - StackOverflow is the most popular. Spaces in variable/file names are BAD. A variable is an object or column that you create in R. For example, if you have a list of student names (student_names = list(&quot;John&quot;, &quot;Peter&quot;, &quot;Sebastian&quot;), the variable here would be student_names. Let’s get into the habit of using underscores ’_’ or dashes ‘-’ or periods ‘.’ to separate words instead of spaces. From the computers side of variable name storage, it’s much safe to declare a variable name such as data_file as opposed to data file Keep in mind, these will make more sense after we get more familiar with R - it’s alright if they’re confusing right now! "],
["r-coding-fundamentals.html", "4 R Coding Fundamentals 4.1 Entering Input 4.2 Running Code 4.3 Evaluation 4.4 R Objects 4.5 Numbers 4.6 Attributes 4.7 Creating Vectors 4.8 Mixing Objects 4.9 Explicit Coercion 4.10 Matrices 4.11 Lists 4.12 Factors 4.13 Missing Values 4.14 Data Frames 4.15 Names 4.16 Summary", " 4 R Coding Fundamentals Now that we’re comfortable with R Studio and have some definitions under our belt, let’s dive in a little into some R code and discuss it. These fundamentals can always be referred back to when we might be stuck coding later on. 4.1 Entering Input In the R Script area, we write code. Whenever we want to assign a variable, we do so using the assignment operator. The &lt;- symbol is the assignment operator. We can also use = which is a bit more intuitive. It is alright to interchange these when assigning variables. val &lt;- 1 print(val) ## [1] 1 val ## [1] 1 msg &lt;- &quot;hello&quot; val and msg are both variables that we assigned. We use the # character to write comments inside our code. Commented code is NOT executed by R. x &lt;- ## Incomplete expression Anything to the right of the # (including the # itself) is ignored. 4.2 Running Code After placing the above code in your R Script area, we can run the code. Code execution is done in the R Console. We can “send” our code in the R Script to the R Console using the Run Button, ctrl + enter (Windows), or cmd + enter (Mac). We can select specific lines of code to run, larger chunks, or the entire R Script. 4.3 Evaluation When a complete expression is entered at the prompt, it is evaluated and the result of the evaluated expression is returned. The result may be auto-printed. val &lt;- 14 ## nothing printed val ## auto-printing occurs ## [1] 14 print(val) ## explicit printing ## [1] 14 The [1] shown in the output indicates that x is a vector and 14 is its first element. Typically we do not explicitly print variables since auto-printing is easier. When an R vector is printed you will notice that an index for the vector is printed in square brackets [] on the side. For example, see this integer sequence of length 10. my_seq &lt;- 10:20 my_seq ## [1] 10 11 12 13 14 15 16 17 18 19 20 Notice the [1] that preceeds the sequence. The output inside the square bracket is not part of the vector itself, it’s just part of the printed output that has additional information to be more user-friendly. This extra information is not part of the object itself. Also note that we used the : operator to create a sequence of integers from 10 to 20 (10:20). Note that the : operator is used to create integer sequences. 4.4 R Objects R has five basic or “atomic” classes of objects: character numeric (real numbers) integer complex logical (True/False) The most basic type of R object is a vector. Empty vectors can be created with the vector() function. There is really only one rule about vectors in R, which is that A vector can only contain objects of the same class. But of course, like any good rule, there is an exception, which is a list, which we will get to a bit later. A list is represented as a vector but can contain objects of different classes. Indeed, that’s usually why we use them. 4.5 Numbers Numbers in R are generally treated as numeric objects. We can explicitly declare numbers as integers, floats, etc., but I won’t cover that here. There is also a special number Inf which represents infinity. This allows us to represent entities like 1 / 0. This way, Inf can be used in ordinary calculations; e.g. 1 / Inf is 0. The value NaN represents an undefined value (“not a number”); e.g. 0 / 0; NaN can also be thought of as a missing value (more on that later) 4.6 Attributes R objects can have attributes, which are like metadata for the object. These metadata can be very useful in that they help to describe the object. For example, column names on a data frame help to tell us what data are contained in each of the columns. Some examples of R object attributes are names, dimnames dimensions (e.g. matrices, arrays) class (e.g. integer, numeric) length other user-defined attributes/metadata Attributes of an object (if any) can be accessed using the attributes() function. Not all R objects contain attributes, in which case the attributes() function returns NULL. 4.7 Creating Vectors The c() function is referred to as the concatenate function. Using this, we can create vectors of objects by concatenating them together. x &lt;- c(1.25, 2.50) ## numeric x &lt;- c(TRUE, FALSE) ## logical x &lt;- c(T, F) ## logical x &lt;- c(&quot;yes&quot;, &quot;no&quot;, &quot;maybe&quot;) ## character x &lt;- 25:44 ## integer x &lt;- c(1+2i, 3+8i) ## complex Note that in the above example, T and F are short-hand ways to specify TRUE and FALSE. However, in general one should try to use the explicit TRUE and FALSE values when indicating logical values. 4.8 Mixing Objects There are occasions when different classes of R objects get mixed together. Sometimes this happens by accident but it can also happen on purpose. So what happens with the following code? y &lt;- c(1.7, &quot;a&quot;) ## character y &lt;- c(TRUE, 2) ## numeric y &lt;- c(&quot;a&quot;, TRUE) ## character In each case above, we are mixing objects of two different classes in a vector. But remember that the only rule about vectors says this is not allowed. When different objects are mixed in a vector, coercion occurs so that every element in the vector is of the same class. In the example above, we see the effect of implicit coercion. What R tries to do is find a way to represent all of the objects in the vector in a reasonable fashion. Sometimes this does exactly what you want and…sometimes not. For example, combining a numeric object with a character object will create a character vector, because numbers can usually be easily represented as strings. 4.9 Explicit Coercion Objects can be explicitly coerced from one class to another using the as.* functions, if available. x &lt;- 0:10 class(x) ## [1] &quot;integer&quot; as.numeric(x) ## [1] 0 1 2 3 4 5 6 7 8 9 10 as.logical(x) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE as.character(x) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; Sometimes, R can’t figure out how to coerce an object and this can result in NAs being produced. x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA as.logical(x) ## [1] NA NA NA as.complex(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA When nonsensical coercion takes place, you will usually get a warning from R. 4.10 Matrices Matrices are vectors with a dimension attribute. The dimension attribute is itself an integer vector of length 2 (number of rows, number of columns) m &lt;- matrix(nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA dim(m) ## [1] 2 3 attributes(m) ## $dim ## [1] 2 3 Matrices are constructed column-wise, so entries can be thought of starting in the “upper left” corner and running down the columns. m &lt;- matrix(1:6, nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Matrices can also be created directly from vectors by adding a dimension attribute. m &lt;- 1:10 m ## [1] 1 2 3 4 5 6 7 8 9 10 dim(m) &lt;- c(2, 5) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 Matrices can be created by column-binding or row-binding with the cbind() and rbind() functions. x &lt;- 1:3 y &lt;- 10:12 cbind(x, y) ## x y ## [1,] 1 10 ## [2,] 2 11 ## [3,] 3 12 rbind(x, y) ## [,1] [,2] [,3] ## x 1 2 3 ## y 10 11 12 4.11 Lists Lists are a special type of vector that can contain elements of different classes. Lists are a very important data type in R and you should get to know them well. Lists, in combination with the various “apply” functions discussed later, make for a powerful combination. Lists can be explicitly created using the list() function, which takes an arbitrary number of arguments. x &lt;- list(1, &quot;a&quot;, TRUE) x ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE We can also create an empty list of a prespecified length with the vector() function x &lt;- vector(&quot;list&quot;, length = 5) x ## [[1]] ## NULL ## ## [[2]] ## NULL ## ## [[3]] ## NULL ## ## [[4]] ## NULL ## ## [[5]] ## NULL 4.12 Factors Factors are used to represent categorical data and can be unordered or ordered. One can think of a factor as an integer vector where each integer has a label. Factors are important in statistical modeling and are treated specially by modelling functions like lm() and glm(). Using factors with labels is better than using integers because factors are self-describing. Having a variable that has values “Male” and “Female” is better than a variable that has values 1 and 2. Factor objects can be created with the factor() function. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: no yes table(x) ## x ## no yes ## 2 3 ## See the underlying representation of factor unclass(x) ## [1] 2 2 1 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; Often factors will be automatically created for you when you read a dataset in using a function like read.table(). Those functions often default to creating factors when they encounter data that look like characters or strings. The order of the levels of a factor can be set using the levels argument to factor(). This can be important in linear modelling because the first level is used as the baseline level. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## Levels are put in alphabetical order ## [1] yes yes no yes no ## Levels: no yes x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: yes no 4.13 Missing Values Missing values are denoted by NA or NaN for q undefined mathematical operations. is.na() is used to test objects if they are NA is.nan() is used to test for NaN NA values have a class also, so there are integer NA, character NA, etc. A NaN value is also NA but the converse is not true ## Create a vector with NAs in it x &lt;- c(1, 2, NA, 10, 3) ## Return a logical vector indicating which elements are NA is.na(x) ## [1] FALSE FALSE TRUE FALSE FALSE ## Return a logical vector indicating which elements are NaN is.nan(x) ## [1] FALSE FALSE FALSE FALSE FALSE ## Now create a vector with both NA and NaN values x &lt;- c(1, 2, NaN, NA, 4) is.na(x) ## [1] FALSE FALSE TRUE TRUE FALSE is.nan(x) ## [1] FALSE FALSE TRUE FALSE FALSE 4.14 Data Frames Data frames are used to store tabular data in R. They are an important type of object in R and are used in a variety of statistical modeling applications. We’ll be working with many dataframes throughout these tutorials. Data frames are represented as a special type of list where every element of the list has to have the same length. Each element of the list can be thought of as a column and the length of each element of the list is the number of rows. Unlike matrices, data frames can store different classes of objects in each column. Matrices must have every element be the same class (e.g. all integers or all numeric). In addition to column names, indicating the names of the variables or predictors, data frames have a special attribute called row.names which indicate information about each row of the data frame. Data frames are usually created by reading in a dataset using the read.table() or read.csv(). However, data frames can also be created explicitly with the data.frame() function or they can be coerced from other types of objects like lists. Data frames can be converted to a matrix by calling data.matrix(). While it might seem that the as.matrix() function should be used to coerce a data frame to a matrix, almost always, what you want is the result of data.matrix(). x &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F)) x ## foo bar ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 FALSE nrow(x) ## [1] 4 ncol(x) ## [1] 2 4.15 Names R objects can have names, which is very useful for writing readable code and self-describing objects. Here is an example of assigning names to an integer vector. x &lt;- 1:3 names(x) ## NULL names(x) &lt;- c(&quot;New York&quot;, &quot;Seattle&quot;, &quot;Los Angeles&quot;) x ## New York Seattle Los Angeles ## 1 2 3 names(x) ## [1] &quot;New York&quot; &quot;Seattle&quot; &quot;Los Angeles&quot; Lists can also have names, which is often very useful. x &lt;- list(&quot;Los Angeles&quot; = 1, Boston = 2, London = 3) x ## $`Los Angeles` ## [1] 1 ## ## $Boston ## [1] 2 ## ## $London ## [1] 3 names(x) ## [1] &quot;Los Angeles&quot; &quot;Boston&quot; &quot;London&quot; Matrices can have both column and row names. m &lt;- matrix(1:4, nrow = 2, ncol = 2) dimnames(m) &lt;- list(c(&quot;a&quot;, &quot;b&quot;), c(&quot;c&quot;, &quot;d&quot;)) m ## c d ## a 1 3 ## b 2 4 Column names and row names can be set separately using the colnames() and rownames() functions. colnames(m) &lt;- c(&quot;h&quot;, &quot;f&quot;) rownames(m) &lt;- c(&quot;x&quot;, &quot;z&quot;) m ## h f ## x 1 3 ## z 2 4 Note that for data frames, there is a separate function for setting the row names, the row.names() function. Also, data frames do not have column names, they just have names (like lists). So to set the column names of a data frame just use the names() function. Yes, I know its confusing. Here’s a quick summary: Object Set column names Set row names data frame names() row.names() matrix colnames() rownames() 4.16 Summary There are a variety of different builtin-data types in R. In this chapter we have reviewed the following atomic classes: numeric, logical, character, integer, complex vectors, lists factors missing values data frames and matrices All R objects can have attributes that help to describe what is in the object. Perhaps the most useful attribute is names, such as column and row names in a data frame, or simply names in a vector or list. Attributes like dimensions are also important as they can modify the behavior of objects, like turning a vector into a matrix. The content in this section was adapted from Dr. Roger Peng "],
["basic-r-scripts.html", "5 Basic R Scripts 5.1 Global Carbon-Dioxide Concentrations 5.2 Cars - Motor Trends Magazine Data", " 5 Basic R Scripts In this example, we’ll begin with data science question and answer it in R. We’ll go through these scripts line by line to show how we can use R. To follow along, copy each of these lines and paste them in your R Script (top left quadrant). Once it’s pasted there, we can run each line and view the output in the R Console (bottom left quadrant). 5.1 Global Carbon-Dioxide Concentrations CO2 is a greenhouse gas responsible for trapping heat. Human’s have released more CO2 into the atmosphere through industrialism. How have global carbon-dioxide (CO2) concentrations changed over time? First, we load the dataset. In our case, the dataset we’ll be using is pre-built into R as co2, meaning we don’t need to download this dataset, we just need to call it. The co2 dataset contains atmospheric concentrations of CO2 are expressed in parts per million (ppm). This data is a time-series of monthly CO2 concentrations recorded between 1959 and 1997. First, let’s make sure the pre-built data is installed correcly. co2 ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct ## 1959 315.42 316.31 316.50 317.56 318.13 318.00 316.39 314.65 313.68 313.18 ## 1960 316.27 316.81 317.42 318.87 319.87 319.43 318.01 315.74 314.00 313.68 ## 1961 316.73 317.54 318.38 319.31 320.42 319.61 318.42 316.63 314.83 315.16 ## 1962 317.78 318.40 319.53 320.42 320.85 320.45 319.45 317.25 316.11 315.27 ## 1963 318.58 318.92 319.70 321.22 322.08 321.31 319.58 317.61 316.05 315.83 ## 1964 319.41 320.07 320.74 321.40 322.06 321.73 320.27 318.54 316.54 316.71 ## 1965 319.27 320.28 320.73 321.97 322.00 321.71 321.05 318.71 317.66 317.14 ## 1966 320.46 321.43 322.23 323.54 323.91 323.59 322.24 320.20 318.48 317.94 ## 1967 322.17 322.34 322.88 324.25 324.83 323.93 322.38 320.76 319.10 319.24 ## 1968 322.40 322.99 323.73 324.86 325.40 325.20 323.98 321.95 320.18 320.09 ## 1969 323.83 324.26 325.47 326.50 327.21 326.54 325.72 323.50 322.22 321.62 ## 1970 324.89 325.82 326.77 327.97 327.91 327.50 326.18 324.53 322.93 322.90 ## 1971 326.01 326.51 327.01 327.62 328.76 328.40 327.20 325.27 323.20 323.40 ## 1972 326.60 327.47 327.58 329.56 329.90 328.92 327.88 326.16 324.68 325.04 ## 1973 328.37 329.40 330.14 331.33 332.31 331.90 330.70 329.15 327.35 327.02 ## 1974 329.18 330.55 331.32 332.48 332.92 332.08 331.01 329.23 327.27 327.21 ## 1975 330.23 331.25 331.87 333.14 333.80 333.43 331.73 329.90 328.40 328.17 ## 1976 331.58 332.39 333.33 334.41 334.71 334.17 332.89 330.77 329.14 328.78 ## 1977 332.75 333.24 334.53 335.90 336.57 336.10 334.76 332.59 331.42 330.98 ## 1978 334.80 335.22 336.47 337.59 337.84 337.72 336.37 334.51 332.60 332.38 ## 1979 336.05 336.59 337.79 338.71 339.30 339.12 337.56 335.92 333.75 333.70 ## 1980 337.84 338.19 339.91 340.60 341.29 341.00 339.39 337.43 335.72 335.84 ## 1981 339.06 340.30 341.21 342.33 342.74 342.08 340.32 338.26 336.52 336.68 ## 1982 340.57 341.44 342.53 343.39 343.96 343.18 341.88 339.65 337.81 337.69 ## 1983 341.20 342.35 342.93 344.77 345.58 345.14 343.81 342.21 339.69 339.82 ## 1984 343.52 344.33 345.11 346.88 347.25 346.62 345.22 343.11 340.90 341.18 ## 1985 344.79 345.82 347.25 348.17 348.74 348.07 346.38 344.51 342.92 342.62 ## 1986 346.11 346.78 347.68 349.37 350.03 349.37 347.76 345.73 344.68 343.99 ## 1987 347.84 348.29 349.23 350.80 351.66 351.07 349.33 347.92 346.27 346.18 ## 1988 350.25 351.54 352.05 353.41 354.04 353.62 352.22 350.27 348.55 348.72 ## 1989 352.60 352.92 353.53 355.26 355.52 354.97 353.75 351.52 349.64 349.83 ## 1990 353.50 354.55 355.23 356.04 357.00 356.07 354.67 352.76 350.82 351.04 ## 1991 354.59 355.63 357.03 358.48 359.22 358.12 356.06 353.92 352.05 352.11 ## 1992 355.88 356.63 357.72 359.07 359.58 359.17 356.94 354.92 352.94 353.23 ## 1993 356.63 357.10 358.32 359.41 360.23 359.55 357.53 355.48 353.67 353.95 ## 1994 358.34 358.89 359.95 361.25 361.67 360.94 359.55 357.49 355.84 356.00 ## 1995 359.98 361.03 361.66 363.48 363.82 363.30 361.94 359.50 358.11 357.80 ## 1996 362.09 363.29 364.06 364.76 365.45 365.01 363.70 361.54 359.51 359.65 ## 1997 363.23 364.06 364.61 366.40 366.84 365.68 364.52 362.57 360.24 360.83 ## Nov Dec ## 1959 314.66 315.43 ## 1960 314.84 316.03 ## 1961 315.94 316.85 ## 1962 316.53 317.53 ## 1963 316.91 318.20 ## 1964 317.53 318.55 ## 1965 318.70 319.25 ## 1966 319.63 320.87 ## 1967 320.56 321.80 ## 1968 321.16 322.74 ## 1969 322.69 323.95 ## 1970 323.85 324.96 ## 1971 324.63 325.85 ## 1972 326.34 327.39 ## 1973 327.99 328.48 ## 1974 328.29 329.41 ## 1975 329.32 330.59 ## 1976 330.14 331.52 ## 1977 332.24 333.68 ## 1978 333.75 334.78 ## 1979 335.12 336.56 ## 1980 336.93 338.04 ## 1981 338.19 339.44 ## 1982 339.09 340.32 ## 1983 340.98 342.82 ## 1984 342.80 344.04 ## 1985 344.06 345.38 ## 1986 345.48 346.72 ## 1987 347.64 348.78 ## 1988 349.91 351.18 ## 1989 351.14 352.37 ## 1990 352.69 354.07 ## 1991 353.64 354.89 ## 1992 354.09 355.33 ## 1993 355.30 356.78 ## 1994 357.59 359.05 ## 1995 359.61 360.74 ## 1996 360.80 362.38 ## 1997 362.49 364.34 This dataset is stored in R as co2. We can create a new variable called co2_data that replicates this co2 dataset. co2_data &lt;- co2 co2_data ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct ## 1959 315.42 316.31 316.50 317.56 318.13 318.00 316.39 314.65 313.68 313.18 ## 1960 316.27 316.81 317.42 318.87 319.87 319.43 318.01 315.74 314.00 313.68 ## 1961 316.73 317.54 318.38 319.31 320.42 319.61 318.42 316.63 314.83 315.16 ## 1962 317.78 318.40 319.53 320.42 320.85 320.45 319.45 317.25 316.11 315.27 ## 1963 318.58 318.92 319.70 321.22 322.08 321.31 319.58 317.61 316.05 315.83 ## 1964 319.41 320.07 320.74 321.40 322.06 321.73 320.27 318.54 316.54 316.71 ## 1965 319.27 320.28 320.73 321.97 322.00 321.71 321.05 318.71 317.66 317.14 ## 1966 320.46 321.43 322.23 323.54 323.91 323.59 322.24 320.20 318.48 317.94 ## 1967 322.17 322.34 322.88 324.25 324.83 323.93 322.38 320.76 319.10 319.24 ## 1968 322.40 322.99 323.73 324.86 325.40 325.20 323.98 321.95 320.18 320.09 ## 1969 323.83 324.26 325.47 326.50 327.21 326.54 325.72 323.50 322.22 321.62 ## 1970 324.89 325.82 326.77 327.97 327.91 327.50 326.18 324.53 322.93 322.90 ## 1971 326.01 326.51 327.01 327.62 328.76 328.40 327.20 325.27 323.20 323.40 ## 1972 326.60 327.47 327.58 329.56 329.90 328.92 327.88 326.16 324.68 325.04 ## 1973 328.37 329.40 330.14 331.33 332.31 331.90 330.70 329.15 327.35 327.02 ## 1974 329.18 330.55 331.32 332.48 332.92 332.08 331.01 329.23 327.27 327.21 ## 1975 330.23 331.25 331.87 333.14 333.80 333.43 331.73 329.90 328.40 328.17 ## 1976 331.58 332.39 333.33 334.41 334.71 334.17 332.89 330.77 329.14 328.78 ## 1977 332.75 333.24 334.53 335.90 336.57 336.10 334.76 332.59 331.42 330.98 ## 1978 334.80 335.22 336.47 337.59 337.84 337.72 336.37 334.51 332.60 332.38 ## 1979 336.05 336.59 337.79 338.71 339.30 339.12 337.56 335.92 333.75 333.70 ## 1980 337.84 338.19 339.91 340.60 341.29 341.00 339.39 337.43 335.72 335.84 ## 1981 339.06 340.30 341.21 342.33 342.74 342.08 340.32 338.26 336.52 336.68 ## 1982 340.57 341.44 342.53 343.39 343.96 343.18 341.88 339.65 337.81 337.69 ## 1983 341.20 342.35 342.93 344.77 345.58 345.14 343.81 342.21 339.69 339.82 ## 1984 343.52 344.33 345.11 346.88 347.25 346.62 345.22 343.11 340.90 341.18 ## 1985 344.79 345.82 347.25 348.17 348.74 348.07 346.38 344.51 342.92 342.62 ## 1986 346.11 346.78 347.68 349.37 350.03 349.37 347.76 345.73 344.68 343.99 ## 1987 347.84 348.29 349.23 350.80 351.66 351.07 349.33 347.92 346.27 346.18 ## 1988 350.25 351.54 352.05 353.41 354.04 353.62 352.22 350.27 348.55 348.72 ## 1989 352.60 352.92 353.53 355.26 355.52 354.97 353.75 351.52 349.64 349.83 ## 1990 353.50 354.55 355.23 356.04 357.00 356.07 354.67 352.76 350.82 351.04 ## 1991 354.59 355.63 357.03 358.48 359.22 358.12 356.06 353.92 352.05 352.11 ## 1992 355.88 356.63 357.72 359.07 359.58 359.17 356.94 354.92 352.94 353.23 ## 1993 356.63 357.10 358.32 359.41 360.23 359.55 357.53 355.48 353.67 353.95 ## 1994 358.34 358.89 359.95 361.25 361.67 360.94 359.55 357.49 355.84 356.00 ## 1995 359.98 361.03 361.66 363.48 363.82 363.30 361.94 359.50 358.11 357.80 ## 1996 362.09 363.29 364.06 364.76 365.45 365.01 363.70 361.54 359.51 359.65 ## 1997 363.23 364.06 364.61 366.40 366.84 365.68 364.52 362.57 360.24 360.83 ## Nov Dec ## 1959 314.66 315.43 ## 1960 314.84 316.03 ## 1961 315.94 316.85 ## 1962 316.53 317.53 ## 1963 316.91 318.20 ## 1964 317.53 318.55 ## 1965 318.70 319.25 ## 1966 319.63 320.87 ## 1967 320.56 321.80 ## 1968 321.16 322.74 ## 1969 322.69 323.95 ## 1970 323.85 324.96 ## 1971 324.63 325.85 ## 1972 326.34 327.39 ## 1973 327.99 328.48 ## 1974 328.29 329.41 ## 1975 329.32 330.59 ## 1976 330.14 331.52 ## 1977 332.24 333.68 ## 1978 333.75 334.78 ## 1979 335.12 336.56 ## 1980 336.93 338.04 ## 1981 338.19 339.44 ## 1982 339.09 340.32 ## 1983 340.98 342.82 ## 1984 342.80 344.04 ## 1985 344.06 345.38 ## 1986 345.48 346.72 ## 1987 347.64 348.78 ## 1988 349.91 351.18 ## 1989 351.14 352.37 ## 1990 352.69 354.07 ## 1991 353.64 354.89 ## 1992 354.09 355.33 ## 1993 355.30 356.78 ## 1994 357.59 359.05 ## 1995 359.61 360.74 ## 1996 360.80 362.38 ## 1997 362.49 364.34 We replicate this dataset and rename it as co2_data so that it’s a variable that is shown in our global environment (top right quadrant). What class is this data? class(co2_data) ## [1] &quot;ts&quot; A ts class is a time-series class. We can print out a summary of the co2 dataset like so. summary(co2_data) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 313.2 323.5 335.2 337.1 350.3 366.8 The summary() function is a base function R offers for quick statistics. How long is this dataset? length(co2_data) ## [1] 468 468 months worth of CO2 observations. Can we plot this dataset? plot(x = co2, ylab = &quot;Atmospheric concentration of CO2 (ppm)&quot;, main = &quot;CO2 Dataset&quot;) Altogether, this script looks like this… # make sure the dataset is loaded - it&#39;s a prebuilt dataset automatically loaded into R co2 # rename the dataset as co2_data so it is visible in our global environment co2_data &lt;- co2 co2_data # identify the class of the co2_data object class(co2_data) # print the summary of the co2_data dataset summary(co2_data) # find the length of the co2_data dataset using the length() function length(co2_data) # plot the dataset using the default plot function plot(x = co2, ylab = &quot;Atmospheric concentration of CO2 (ppm)&quot;, main = &quot;CO2 Dataset&quot;) Above is our script. We run this script in the console. We can save this script and re-run this at any time. An example of this would be saving this file as co2_script.R. Once this is saved, you can close R, re-open it, and re-run your co2_script.R without re-writing any code. 5.2 Cars - Motor Trends Magazine Data The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models). Load the dataset - again this is a pre-loaded dataset, but let’s call on it so we can bring it into our global environment. data(&#39;mtcars&#39;) head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 The head() function is a quick function that prints out the first few rows of a dataset. What’s exactly is mtcars? class(mtcars) ## [1] &quot;data.frame&quot; It’s a data.frame. Data Frames have a different storage than time series. You can also view this dataframe by clicking on the mtcars dataframe in your global environment. What are the dimensions of this dataframe? How many rows and columns does it have? dim(mtcars) ## [1] 32 11 nrow(mtcars) ## [1] 32 ncol(mtcars) ## [1] 11 We have 32 rows and 11 columns within this dataframe. What are our column names? colnames(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; What are our row names (aka the make of the car)? rownames(mtcars) ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; How do we extract individual columns/variables from this dataframe? mtcars[&quot;mpg&quot;] ## mpg ## Mazda RX4 21.0 ## Mazda RX4 Wag 21.0 ## Datsun 710 22.8 ## Hornet 4 Drive 21.4 ## Hornet Sportabout 18.7 ## Valiant 18.1 ## Duster 360 14.3 ## Merc 240D 24.4 ## Merc 230 22.8 ## Merc 280 19.2 ## Merc 280C 17.8 ## Merc 450SE 16.4 ## Merc 450SL 17.3 ## Merc 450SLC 15.2 ## Cadillac Fleetwood 10.4 ## Lincoln Continental 10.4 ## Chrysler Imperial 14.7 ## Fiat 128 32.4 ## Honda Civic 30.4 ## Toyota Corolla 33.9 ## Toyota Corona 21.5 ## Dodge Challenger 15.5 ## AMC Javelin 15.2 ## Camaro Z28 13.3 ## Pontiac Firebird 19.2 ## Fiat X1-9 27.3 ## Porsche 914-2 26.0 ## Lotus Europa 30.4 ## Ford Pantera L 15.8 ## Ferrari Dino 19.7 ## Maserati Bora 15.0 ## Volvo 142E 21.4 We can also extract the vector of data using the $ operator. mtcars$mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 ## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 ## [31] 15.0 21.4 What are the statistics like for each variable? summary(mtcars) ## mpg cyl disp hp ## Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 ## Median :19.20 Median :6.000 Median :196.3 Median :123.0 ## Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 ## drat wt qsec vs ## Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 ## 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 ## Median :3.695 Median :3.325 Median :17.71 Median :0.0000 ## Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 ## 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 ## Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 ## am gear carb ## Min. :0.0000 Min. :3.000 Min. :1.000 ## 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 ## Median :0.0000 Median :4.000 Median :2.000 ## Mean :0.4062 Mean :3.688 Mean :2.812 ## 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 ## Max. :1.0000 Max. :5.000 Max. :8.000 Notice that now the summary() function is printing out the summary statistics for each column (aka variable) within our dataframe (mtcars) What if we just wanted to focus on the first 5 cars in the dataset? We need to index. mtcars[1:5,] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Remember, data is stored as Row, Column. Above, we’re indexing the first 5 rows and then including all columns. What if we just wanted to focus on the first column? mtcars[1:5,1] ## [1] 21.0 21.0 22.8 21.4 18.7 That’s the mpg column of the first 5 cars. Which car has the best miles per gallon (mpg)? barplot(height = mtcars$mpg[1:5], names.arg = rownames(mtcars)[1:5]) The Datsun 710 has the highest MPG rating of the first 5 cars (rows) in the dataset. The entire script looks like this: # load the data - the mtcars dataset is pre-built data(&#39;mtcars&#39;) # print out the first few rows of the dataset using the head() function head(mtcars) # print the class of the mtcars dataset class(mtcars) # dimensions of the mtcars dataframe dim(mtcars) # number of rows nrow(mtcars) # number of columns ncol(mtcars) # column names colnames(mtcars) # row names rownames(mtcars) # selecting the miles per gallon column mtcars[&quot;mpg&quot;] # selecting the vector of the mpg column mtcars$mpg # printing a summary of the dataframe summary(mtcars) # indexing the first 5 rows, including all of the columns mtcars[1:5,] # indexing the first 5 rows and the 1st column mtcars[1:5,1] # creating a barplot of mpg for the first 5 cars barplot(height = mtcars$mpg[1:5], names.arg = rownames(mtcars)[1:5]) "],
["scientific-r-scripts.html", "6 Scientific R Scripts 6.1 Script Breakdown 6.2 In Class Exercise", " 6 Scientific R Scripts So far, the examples of R scripts we’ve shown have been general purpose scripts. For this week, we’re going to cover an example where we want to plot sea surface temperature from a given netCDF file. A netCDF file (network Common Data Format) is an advanced filetype that is incredibly efficient at storing data and heavily used in physical sciences. Within each file, metadata (time, latitude info, longitude info, projection, etc.), and variables (sea surface temperature, latitude points, longitude points, chlorophyll, etc.) can be found. The netCDF file we’ll be looking at in this example is OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc. This is a data file from the GOES-16 (Geostationary Operational Environmental Satellite) satellite that shows a snapshot of the Northwest Atlantic Ocean and Eastern Seaboard. So we have the data, but what does it look like? A scientific R Script might look like this: # James Simkins # Load libraries library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) lat &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;latitude&quot;) lon &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;longitude&quot;) # convert sst from Kelvin to Celsius sstC &lt;- sstK - 273.15 # remove values below 0C sstC[sstC &lt; 0] = NA # Plot the matrix fields::image.plot(x=lon, y=lat, z=sstC, legend.lab=&quot;Celsius&quot;) title(&quot;GOES-R SST Product 7/25/2019 19:00 UTC&quot;) 6.1 Script Breakdown # Load libraries library(ncdf4) library(fields) In R, we need to call on packages/libraries that we want to load in. As a reminder, packages are the toolbox we want to bring into R and the functions inside each package are the tools within that specific toolbox. The library() base function loads packages. After we load a package, R will know what we mean when we call on a function from that package. # Load libraries library(ncdf4) library(fields) ####################################### ncFile &lt;- ncdf4::nc_open(filename=&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) lat &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;latitude&quot;) lon &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;longitude&quot;) Our object name is ncFile and it holds an opened NetCDF file. We open this file via the nc_open() function that’s within the ncdf4 library. Note the ncdf4::nc_open() syntax. Using this syntax, we explicitly tell R we wish to use the nc_open() function within (::) the ncdf4 package. This is not necessary after loading the ncdf4 package above but is still important ot know. Notice we can use either &lt;- or = for objects (like ncFile or sstK) but I MUST use = within the function ‘walls’ (the parantheses). We open the netcdf file and then extract what we want out of it using ncvar_get(), which is short for “netcdf variable get”. Confused about how to use ncvar_get()? Try running help(ncvar_get) in your console. # Load libraries library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(filename=&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) ####################################### # convert sst from Kelvin to Celsius sstC &lt;- sstK - 273.15 The SST variable from the netCDF file was in Kelvin and we want to convert it to Celsius. Right now, sstK is a matrix. How do I know this? Look at your environment, or simply type into your console: # Load libraries library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(filename=&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) ####################################### class(sstK) ## [1] &quot;matrix&quot; Class is a useful function that is loaded with the base library everytime you fire up R. It tells us what type of object we have. Now that we know this is a matrix, we can subtract 0 Celsius, or 273.15 Kelvin. When we have a matrix in R and perform any math on it, it does that math on each and every matrix value. #Quick and Dirty Quality Control There are bad values that crept into the dataset and we need to convert all of them to NaN (aka Not A Number…also known as NA (Not Available) in R). How do we know there are bad values in this dataset? # Load libraries library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(filename=&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) ####################################### summary(as.vector(sstK)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## -999.0 286.9 300.0 278.2 302.0 310.0 2175822 summary() is another great base function. In order to use it on a matrix, we need to convert it to a vector - summary can’t do 2 dimensional objects like matrices, it needs a one dimensional vector of numbers. Notice the Min in the summary output. -999? No way is that a valid Kelvin value, especially since we subtract another 273.15 to this number to make the the Celsius matrix. So clearly we have some bad data that we need to convert to NA’s. We do this by… library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) lat &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;latitude&quot;) lon &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;longitude&quot;) # convert sst from Kelvin to Celsius sstC &lt;- sstK - 273.15 ####################################### # remove values below 0C sstC[sstC &lt; 0] = NA This line reads as: sstC where sstC is less than 0 equals NA. The brackets here can be thought of as the ‘condition’, that is what you’re looking to change. This is called a vector operation, which we will get more into later but these are important becuase it’s far faster to do this than a for loop. library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) lat &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;latitude&quot;) lon &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;longitude&quot;) # convert sst from Kelvin to Celsius sstC &lt;- sstK - 273.15 # remove values below 0C ####################################### sstC[sstC &lt; 0] = NA summary(as.vector(sstC)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0.0 19.8 27.6 24.1 29.0 36.8 2679819 Now we see that our summary looks good (even though we’re looking at a matrix in celsius now). So all that’s left to do is plot this up… # James Simkins # Load libraries library(ncdf4) library(fields) ncFile &lt;- ncdf4::nc_open(&quot;~/Documents/Github/geog473-673/datasets/OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc&quot;) sstK &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;SST&quot;) lat &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;latitude&quot;) lon &lt;- ncdf4::ncvar_get(nc=ncFile, varid=&quot;longitude&quot;) # convert sst from Kelvin to Celsius sstC &lt;- sstK - 273.15 # remove values below 0C sstC[sstC &lt; 0] = NA ####################################### # Plot the matrix fields::image.plot(x=lon, y=lat, z=sstC, legend.lab=&quot;Celsius&quot;) title(&quot;GOES-R SST Product 7/25/2019 19:00 UTC&quot;) Now we plot this up using the image.plot() function from the fields library. image.plot() takes the arguments x, y, and z. This is a 2 dimensional dataset of Sea Surface Temperature where the x is longitude, the y is latitude, and what we plot within the box (z) is sstC. Notice that for this kind of plot, the ‘title()’ function is a separate function rather than an argument that goes inside of image.plot(). Remember, if you’re ever confused about something like this just tell R you need ‘help()’. 6.2 In Class Exercise Go to https://github.com/jsimkins2/geog473-673/tree/master/datasets Download ‘OR_ABI-L2-SSTF-M3_G16_s20192081300453_e20192081400161_c20192081406297.nc’ Make simple plot of the ‘DQF’ (Data Quality Flag) variable -Hint: You may have to use ‘install.packages’ in your console first Aim for something like this: 6.2.1 Further Explanation of DataTypes If you look into your environment from the in class exercise, you’ll notice under the ‘Data’ tab you have a large matrix of the DQF values. R stores these matrices without the column/row identifier (aka lat &amp; lon). We provide the image.plot() function with the lon &amp; lat arrays becuase it doesn’t know what the x &amp; y coordinates are of the matrix. Notice that the environment tells you the dimensions - the matrix is 2778 x 1989. R is indexed from 1 to the length of the dimension. Here is what I mean: dim(sstC) is 2778 1989 dim(lat) is 1989 lat[0] is numeric(0) lat[1] is 16.00283 lat[1989] is 51.98563 lat[1990] is NA The above tests are referred to as indexing. The 1st point of the lat array is 16.00283. In R, we index using brackets []. If you want to find more values other than just a single point, the procedure is referred to as indexing/slicing/subsetting. lat[1:10] is 16.00283 16.02093 16.03903 16.05713 16.07523 16.09333 16.11143 16.12953 16.14763 16.16573 The lat object we’ve been exploring here is an ‘array’. An array is a vector with one or more dimensions. So, an array with one dimension is (almost) the same as a vector. An array with two dimensions is (almost) the same as a matrix. An array with three or more dimensions is an n-dimensional array. A vector is what is called an array in all other programming languages except R — a collection of cells with a fixed size where all cells hold the same type (integers or characters or reals or whatever). "],
["time-series-fun-with-deos.html", "7 Time Series fun with DEOS 7.1 For Loops 7.2 DEOS Data 7.3 Assignment", " 7 Time Series fun with DEOS This week we’ll look at some Time-Series data from DEOS. Delaware has the highest concentration of environmental monitoring stations in the country thanks to DEOS (Delaware Environmental Observing System) which is controlled by University of Delaware’s CEMA (Center for Environmental Monitoring and Analysis). The data collected using this dense network is useful for a variety of purposes. Before we dive into the data, let’s cover an important skill - the for loop. 7.1 For Loops For loops &amp; conditional statements are a key skill in programming. They allow you to process through large datasets or multiple datasets thus minimizing the amount of manual work you need to do. The basic for loop looks like this… # Generate sequence of numbers from 1 to 10 using the seq() function (seq for sequence) numbersList = seq(from=1,to=10,by=1) # Multiply each number in the numbersList by 8 and print the result for (i in numbersList){ temNumber = i * 8 print(temNumber) } ## [1] 8 ## [1] 16 ## [1] 24 ## [1] 32 ## [1] 40 ## [1] 48 ## [1] 56 ## [1] 64 ## [1] 72 ## [1] 80 Notice the general structure of R for loops. for signals to R you’re beginning a for loop, which requires the general structure to look like: for (something in something inside these parentheses){ do something within these curly brackets } Yes, you must have these parentheses and curly brackets present and surrounding the appropriate code. If you forget a parentheses or curly bracket you’ll have errors pop up…this happens to advanced programmers all the time, so don’t be discouraged if it takes time getting used to this. The general structure is always: for(condition){do something}. If statements are set up the same way # Generate sequence of numbers from 1 to 10 using the seq() function (seq for sequence) numbersList = seq(from=1,to=10,by=1) # Multiply each number in the numbersList by 8 and print the result for (i in numbersList){ if (i==4){ temNumber = i * 8 print(temNumber) } } ## [1] 32 This is referred to as a nested loop, because there is a conditional statement within another one. Key takeaway here: in programming languages, = is an assignment (i.e. x = 4), whereas == is an equality test (i == 4). To put this loop in layman’s terms: for i in numbersList, if i is equal to 4, multiply i by 8 and then print temNumber. We can also have nested for loops. # Generate sequence of numbers from 1 to 3 this time using the seq() function (seq for sequence) numbersList = seq(from=1,to=3,by=1) lettersList = list(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) for (num in numbersList){ for (let in lettersList){ print(c(num,let)) } } ## [1] &quot;1&quot; &quot;A&quot; ## [1] &quot;1&quot; &quot;B&quot; ## [1] &quot;1&quot; &quot;C&quot; ## [1] &quot;2&quot; &quot;A&quot; ## [1] &quot;2&quot; &quot;B&quot; ## [1] &quot;2&quot; &quot;C&quot; ## [1] &quot;3&quot; &quot;A&quot; ## [1] &quot;3&quot; &quot;B&quot; ## [1] &quot;3&quot; &quot;C&quot; You can name the object within the list whatever you want (i, j, num, let, etc.). Also, c() is the concatenate function that combines values into a vector or list. The order doesn’t matter in this for loop… # Generate sequence of numbers from 1 to 3 this time using the seq() function (seq for sequence) numbersList = seq(from=1,to=3,by=1) lettersList = list(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) for (let in lettersList){ for (num in numbersList){ print(c(num,let)) } } ## [1] &quot;1&quot; &quot;A&quot; ## [1] &quot;2&quot; &quot;A&quot; ## [1] &quot;3&quot; &quot;A&quot; ## [1] &quot;1&quot; &quot;B&quot; ## [1] &quot;2&quot; &quot;B&quot; ## [1] &quot;3&quot; &quot;B&quot; ## [1] &quot;1&quot; &quot;C&quot; ## [1] &quot;2&quot; &quot;C&quot; ## [1] &quot;3&quot; &quot;C&quot; But it does in this one… # Generate sequence of numbers from 1 to 10 using the seq() function (seq for sequence) numbersList = seq(from=1,to=10,by=1) # Multiply each number in the numbersList by 8 and print the result if (i==4){ for (i in numbersList){ temNumber = i * 8 print(temNumber) } } Here’s one more example for multi conditional statement with an else… # Generate sequence of numbers from 1 to 3 this time using the seq() function (seq for sequence) numbersList = seq(from=1,to=3,by=1) lettersList = list(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) for (num in numbersList){ for (let in lettersList){ if (num == 3 &amp;&amp; let == &quot;B&quot;){ print(c(num,let)) } else{ print(&quot;Not what we want&quot;) } } } ## [1] &quot;Not what we want&quot; ## [1] &quot;Not what we want&quot; ## [1] &quot;Not what we want&quot; ## [1] &quot;Not what we want&quot; ## [1] &quot;Not what we want&quot; ## [1] &quot;Not what we want&quot; ## [1] &quot;Not what we want&quot; ## [1] &quot;3&quot; &quot;B&quot; ## [1] &quot;Not what we want&quot; &amp;&amp; means “and” … || means “or”…these are useful in multi conditional statements. The else statement is an appendage of the if statement. It basically means if num == 3 and let == B is false, print &quot;not what we want&quot;. Notice that the ‘else’ statement is outside of the if statement but immediately after it. In Class Exercise: debug this for loop soiltype &lt;- list(&quot;sand&quot;, &quot;silt&quot;, &quot;saline&quot;, &quot;clay&quot;, &quot;peat&quot;) permeability &lt;- c(0.09, 0.05, 0.03, 0.01, 0.005) for (s in seq(length(soiltype)){ print(a) for (p in permeability) if (p == 0.05 | p == 0.005){ print(permeability[s]) } } } And get this output… ## [1] 1 ## [1] 0.09 ## [1] 0.09 ## [1] 2 ## [1] 0.05 ## [1] 0.05 ## [1] 3 ## [1] 0.03 ## [1] 0.03 ## [1] 4 ## [1] 0.01 ## [1] 0.01 ## [1] 5 ## [1] 0.005 ## [1] 0.005 7.2 DEOS Data The dataset we’ll be using is called - DEOS.csv . It contains a variety of meteorological variables collected at 5 minute intervals. Let’s dive into the coded example. # load the data using read.csv() deos_data &lt;- read.csv(&quot;/Users/james/Documents/Github/geog473-673/datasets/DEOS.csv&quot;, header = TRUE, skip=0, stringsAsFactors = FALSE) # view the top few rows of data using the head() function head(deos_data) ## Timestamp..UTC. Air.Temperature.deg..C. Dew.Point.Temperature.deg..C. ## 1 2014-04-04 04:05 7.1 4.3 ## 2 2014-04-04 04:10 6.9 4.3 ## 3 2014-04-04 04:15 6.8 4.3 ## 4 2014-04-04 04:20 6.7 4.4 ## 5 2014-04-04 04:25 6.6 4.4 ## 6 2014-04-04 04:30 6.6 4.4 ## Wind.Speed.m.sec. Wind.Direction.deg.. Barometric.Pressure.. ## 1 3.7 351.7 NA ## 2 3.5 352.9 NA ## 3 3.9 357.5 NA ## 4 3.9 356.8 NA ## 5 3.3 5.5 NA ## 6 2.7 18.4 NA ## Solar.Radiation.UNKNOWN. Wind.Gust.Speed..5..m.sec. ## 1 0 5.1 ## 2 0 5.8 ## 3 0 6.2 ## 4 0 5.9 ## 5 0 4.9 ## 6 0 3.5 ## Gage.Precipitation..5..mm. ## 1 0.00 ## 2 0.00 ## 3 0.25 ## 4 0.00 ## 5 0.00 ## 6 0.00 # view summary of the data summary(deos_data) ## Timestamp..UTC. Air.Temperature.deg..C. Dew.Point.Temperature.deg..C. ## Length:182645 Min. :-51.0 Min. :-53.300 ## Class :character 1st Qu.: 7.6 1st Qu.: 2.200 ## Mode :character Median : 15.2 Median : 10.200 ## Mean : 14.1 Mean : 8.505 ## 3rd Qu.: 21.2 3rd Qu.: 16.200 ## Max. : 37.0 Max. : 25.500 ## Wind.Speed.m.sec. Wind.Direction.deg.. Barometric.Pressure.. ## Min. : 0.100 Min. : 0.0 Mode:logical ## 1st Qu.: 1.800 1st Qu.: 99.3 NA&#39;s:182645 ## Median : 2.600 Median :202.2 ## Mean : 2.997 Mean :187.0 ## 3rd Qu.: 3.700 3rd Qu.:258.9 ## Max. :16.700 Max. :360.0 ## Solar.Radiation.UNKNOWN. Wind.Gust.Speed..5..m.sec. Gage.Precipitation..5..mm. ## Min. : 0.0 Min. : 0.100 Min. :0.00000 ## 1st Qu.: 0.0 1st Qu.: 2.900 1st Qu.:0.00000 ## Median : 4.0 Median : 4.400 Median :0.00000 ## Mean : 192.7 Mean : 4.907 Mean :0.01354 ## 3rd Qu.: 313.0 3rd Qu.: 6.400 3rd Qu.:0.00000 ## Max. :1335.0 Max. :24.400 Max. :9.65000 # view variable names colnames(deos_data) ## [1] &quot;Timestamp..UTC.&quot; &quot;Air.Temperature.deg..C.&quot; ## [3] &quot;Dew.Point.Temperature.deg..C.&quot; &quot;Wind.Speed.m.sec.&quot; ## [5] &quot;Wind.Direction.deg..&quot; &quot;Barometric.Pressure..&quot; ## [7] &quot;Solar.Radiation.UNKNOWN.&quot; &quot;Wind.Gust.Speed..5..m.sec.&quot; ## [9] &quot;Gage.Precipitation..5..mm.&quot; #the variable names look wonky because they have spaces in them - spaces in variable names is a big no-no #change the names to something more readable names(deos_data) = c(&quot;datetime&quot;, &quot;air_temperature&quot;, &quot;dewpoint&quot;, &quot;windspeed&quot;, &quot;winddirection&quot;, &quot;pressure&quot;, &quot;solar_radiation&quot;, &quot;wind_gust&quot;, &quot;precipitation&quot;) # print the first datetime value deos_data$datetime[1] ## [1] &quot;2014-04-04 04:05&quot; # view the class of the first date index class(deos_data$datetime) ## [1] &quot;character&quot; # give it a datetime class, notice the format deos_data$datetime = as.POSIXct(deos_data$datetime, format = &#39;%Y-%m-%d %H:%M&#39;) # subset the data using the which.min() and which.max() functions to find our indices low_ind = which.min(deos_data$datetime &lt; &quot;2014-04-04 00:00:00&quot;) upper_ind = which.max(deos_data$datetime &gt; &quot;2015-04-04 23:59&quot;) # plot the dataset by indexing it between teh low_ind and upper_ind plot(deos_data$datetime[low_ind:upper_ind], deos_data$air_temperature[low_ind:upper_ind], type = &quot;l&quot;, col = &#39;red&#39;, xlab = paste0(deos_data$datetime[low_ind], &quot; to &quot;, deos_data$datetime[upper_ind]), ylab = &quot;Celsius&quot;) # add a title to the plot title(&quot;1 Year Air Temperature at Station&quot;) #subset the data using the subset function this time subDeos = subset(deos_data, deos_data$datetime &gt;= &quot;2014-07-04 00:00:00&quot; &amp; deos_data$datetime &lt;= &quot;2014-07-11 23:59:00&quot;) # Now add dewpoint to that plot plot(x = subDeos$datetime, y = subDeos$air_temperature, type = &quot;l&quot;, col = &#39;red&#39;, xlab = paste0(subDeos$datetime[1], &quot; to &quot;, subDeos$datetime[length(subDeos$datetime)]), ylab = &quot;Celsius&quot;, ylim = c(5,40)) # add &quot;lines&quot; to the plot, in this case we want our line to be the dewpoint lines(x = subDeos$datetime, y = subDeos$dewpoint, col = &#39;yellow&#39;) legend(&#39;bottomright&#39;, legend=c(&#39;Air Temp&#39;, &#39;Dew Pt&#39;), col = c(&#39;red&#39;, &#39;yellow&#39;), lty = c(1, 1)) title(&quot;Air Temperature &amp; Dew Point Temperature&quot;) 7.3 Assignment Subset dataset to January 2015 only Convert Wind Speed &amp; Wind Gust data from m/s to mph Plot wind speed and wind gust on same plot - wind gust as points first, then wind speed as a line second Hint: you’ll have to use an argument of type = &quot;p&quot; for wind gust. Add legend Compute correlation coefficient between wind gust and wind speed using cor() function - add to title of plot Deliver Resulting Plot to Canvas assignment week3 Aim for something like this (does not have to be exact)… "],
["oceanography-global-tree-cover.html", "8 Oceanography &amp; Global Tree Cover 8.1 Paste0() 8.2 Rasters 8.3 Assignment", " 8 Oceanography &amp; Global Tree Cover This week we’ll use a different dataset from the GOES-16 satellite to explore new coding practices. We’ll take what we have learned from the example and apply it to a global tree cover dataset. First, let’s cover an important skill - understanding the paste0() function. 8.1 Paste0() Last week we covered the for loop which is an essential programming skill. We also touched on the paste0() function, but this is incredibly useful and should be expanded upon. paste0() is the sister function of paste(), who’s cousin is sprintf() . It depends on preference, but most coders I know gravitate towards paste0(). Let’s check out all 3. # Paste Example 1 - default sep (aka separation) is space paste(&quot;file&quot;, &quot;number&quot;, &quot;32&quot;) ## [1] &quot;file number 32&quot; # Paste Example 2 - set sep to &quot;_&quot; paste(&quot;file&quot;, &quot;number&quot;, &quot;32&quot;, sep = &quot;_&quot;) ## [1] &quot;file_number_32&quot; # Paste0 Example 1 - 0 for 0 separating characters paste0(&quot;file&quot;, &quot;number&quot;, &quot;32&quot;) ## [1] &quot;filenumber32&quot; # sprintf example 1 sprintf(&quot;%s %s %s&quot;, &quot;file&quot;, &quot;number&quot;, &quot;32&quot;) ## [1] &quot;file number 32&quot; # sprintf example 2 person &lt;-&quot;Grover&quot; action &lt;-&quot;flying&quot; message(sprintf(&quot;On %s I realized %s was...\\n%s by the street&quot;, Sys.Date(), person, action)) ## On 2020-08-28 I realized Grover was... ## flying by the street # Notice that paste() is limiting because the separating character is not always present between # each string you&#39;re concatenating # Let&#39;s use paste0 here fileList &lt;- c(&#39;filename1&#39;, &#39;filename2&#39;, &#39;filename3&#39;, &#39;filename4&#39;) dateFolder &lt;- c(&#39;0813&#39;, &#39;0814&#39;, &#39;0815&#39;, &#39;0816&#39;) homeDir &lt;- &quot;~/Documents/&quot; pathList &lt;- list() for (i in 1:length(fileList)){ print(i) tempString &lt;- paste0(homeDir, dateFolder[i], &#39;/&#39;, fileList[i]) pathList[i] &lt;- tempString } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 pathList ## [[1]] ## [1] &quot;~/Documents/0813/filename1&quot; ## ## [[2]] ## [1] &quot;~/Documents/0814/filename2&quot; ## ## [[3]] ## [1] &quot;~/Documents/0815/filename3&quot; ## ## [[4]] ## [1] &quot;~/Documents/0816/filename4&quot; pathList[[1]] ## [1] &quot;~/Documents/0813/filename1&quot; # Now let&#39;s rewrite using sprintf fileList &lt;- c(&#39;filename1&#39;, &#39;filename2&#39;, &#39;filename3&#39;, &#39;filename4&#39;) dateFolder &lt;- c(&#39;0813&#39;, &#39;0814&#39;, &#39;0815&#39;, &#39;0816&#39;) homeDir &lt;- &quot;~/Documents/&quot; pathList &lt;- list() pathList &lt;- sprintf(&quot;%s%s/%s&quot;, homeDir, dateFolder, fileList) pathList ## [1] &quot;~/Documents/0813/filename1&quot; &quot;~/Documents/0814/filename2&quot; ## [3] &quot;~/Documents/0815/filename3&quot; &quot;~/Documents/0816/filename4&quot; pathList[[1]] ## [1] &quot;~/Documents/0813/filename1&quot; #sprintf is a very useful and quick function for combining various strings into longer strings #but paste0 allows you a little more freedom and is slightly more intuitive Debug and fix the following code: # Let&#39;s use paste0 here fileList &lt;- c(&#39;sstData20190912&#39;, &#39;sstData20190913&#39;, &#39;sstData20190914&#39;, &#39;sstData20190915&#39;) dateFolder &lt;- seq(0912, 0915, 1) homeDir &lt;- &quot;~/Documents/&quot; pathList &lt;- list() for (i in fileList){ print(i) tempString &lt;- paste0(homeDir, dateFolder[i], &#39;/&#39;, i) pathList[i] &lt;- tempString } pathList pathList[[1]] The final pathList[[1]] should look like this… &quot;~/Documents/0912/sstData20190912&quot; 8.2 Rasters Rasters offer us a 2 dimensional dataset (matrix) of data with geospatial coordinates. Rasters can come in a variety of filetypes including netCDF, GeoTIFF, CSV (if they come in CSV, they’ll be massive - this is an inefficient datatype), etc. We’ll be looking at the GOES-16 Rolling 1 Day average datafile - GOES_R_ROLLING_1DAY_20190814.nc. The GOES-16 Satellite records sea surface temperatures every hour. A rolling 1 day is an average of the previous 24 hours of record of sea surface temperature (and this dataset is created by CEMA here at UD). library(maptools) # also loads sp package ## Warning: package &#39;maptools&#39; was built under R version 3.6.2 library(sp) library(ncdf4) library(raster) library(rasterVis) library(RColorBrewer) ncFile &lt;- nc_open(&quot;/Users/james/Documents/Github/geog473-673/datasets/GOES_R_ROLLING_1DAY_20190814.nc&quot;) sstGoes &lt;- ncvar_get(ncFile, varid = &quot;sst&quot;) sstRast &lt;- raster(sstGoes) # plot using quick &#39;image&#39; function from raster image(sstRast) # netcdf stores data backwards, so to convert it to raster we need to transpose it sstRast &lt;- t(sstRast) # plot using quick &#39;image&#39; function from raster image(sstRast) # now we see that the data is just upside down, so we use the flip() function sstRast &lt;- flip(sstRast, 2) # plot using quick &#39;image&#39; function from raster image(sstRast) sstRast ## class : RasterLayer ## dimensions : 1989, 2778, 5525442 (nrow, ncol, ncell) ## resolution : 0.0003599712, 0.0005027652 (x, y) ## extent : 0, 1, 0, 1 (xmin, xmax, ymin, ymax) ## crs : NA ## source : memory ## names : layer ## values : 5.344696, 34.9397 (min, max) # notice that the extent and crs information are wrong/not included so let&#39;s fix this lat = ncvar_get(ncFile, &quot;latitude&quot;) lon = ncvar_get(ncFile, &quot;longitude&quot;) # define new extents for the raster extent(sstRast) = c(min(lon), max(lon), min(lat), max(lat)) # define the proj4 projection string crs(sstRast) = &quot;+proj=longlat +datum=WGS84 +no_defs &quot; sstRast ## class : RasterLayer ## dimensions : 1989, 2778, 5525442 (nrow, ncol, ncell) ## resolution : 0.01799352, 0.0180909 (x, y) ## extent : -99.99015, -50.00415, 16.00283, 51.98563 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : layer ## values : 5.344696, 34.9397 (min, max) image(sstRast) # levelplot the sstRast - levelplot is from rasterVis package levelplot(sstRast) # USA shapefiles via the getData function usa &lt;- getData(&#39;GADM&#39;, country = &#39;USA&#39;, level = 1) # Throw together the usa spatial polygons data frame plt &lt;- levelplot(sstRast, margin=F, par.settings=BuRdTheme, main=&quot;GOES-R Rolling SST 08/14&quot;) plt + layer(sp.polygons(usa, col=&#39;black&#39;,fill=&#39;grey&#39;, lwd=0.4)) # Now let&#39;s do the same with geotiff tifFile = &quot;/Users/james/Documents/Github/geog473-673/datasets/goesSST.tif&quot; sstRast = raster(tifFile) # Quick image using raster&#39;s image plot generator function image(sstRast) # Now let&#39;s load a base dataset of world maps that R already has stored data(wrld_simpl) plt &lt;- levelplot(sstRast, margin=F, par.settings=BuRdTheme, main=&quot;GOES-R Rolling SST 08/14&quot;) plt + layer(sp.lines(wrld_simpl, col=&#39;black&#39;, lwd=0.4)) # Let&#39;s do the same plot but with a custom shapefile # note that even though we only point the function to the &#39;.shp&#39; file, the &#39;.shx&#39; and &#39;.dbf&#39; need to be in the same folder for this to work. world.shp &lt;- rgdal::readOGR(&quot;/Users/james/Documents/Github/geog473-673/datasets/world_shpfiles/world.shp&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/Users/james/Documents/Github/geog473-673/datasets/world_shpfiles/world.shp&quot;, layer: &quot;world&quot; ## with 252 features ## It has 2 fields # add custom color theme using brewer.pal from the package RColorBrewer and setting the rasterTheme mapTheme &lt;- rasterTheme(region=brewer.pal(8,&quot;Reds&quot;)) plt &lt;- levelplot(sstRast, margin=F, par.settings=mapTheme, main=&quot;GOES-R Rolling SST 08/14&quot;) plt + layer(sp.lines(world.shp, col=&#39;gray&#39;, lwd=0.4)) 8.3 Assignment Download treecov.nc from the datasets folder Open tree cover % as a variable, remove bad values (i.e. percentages outside of 0 and 100). Plot tree cover variable using a green theme. Be sure to add coastlines via your choice of underlying dataset. Ensure correct latitude/longitudes are displayed. Add title. Submit resulting image to Canvas assignment 4 ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/Users/james/Documents/Github/geog473-673/datasets/world_shpfiles/world.shp&quot;, layer: &quot;world&quot; ## with 252 features ## It has 2 fields "],
["reprojecting-writing-rasters.html", "9 Reprojecting &amp; Writing Rasters 9.1 Indexing Data 9.2 Resampling and Reprojecting 9.3 PNGs 9.4 Writing Rasters 9.5 Assignment", " 9 Reprojecting &amp; Writing Rasters This week work on handling raster datasets that have undesirable projections. We’ll reproject these datasets and then write them to a new datafile that we can use in the future. 9.1 Indexing Data matA=matrix(1:16,4,4) matA ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 matA[2,3] ## [1] 10 matA[c(1,3),c(2,4)] ## [,1] [,2] ## [1,] 5 13 ## [2,] 7 15 matA[1:3,2:4] ## [,1] [,2] [,3] ## [1,] 5 9 13 ## [2,] 6 10 14 ## [3,] 7 11 15 matA[1:2,] ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 matA[,1:2] ## [,1] [,2] ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 matA[1,] ## [1] 1 5 9 13 dim(matA) ## [1] 4 4 ##In Class Exercise: Starting with this code… matA=matrix(1:16,4,4) Make this matrix…. ## [,1] [,2] [,3] [,4] ## [1,] 1 10 18 26 ## [2,] 47 47 47 47 ## [3,] 6 14 22 39 ## [4,] 8 16 24 32 9.2 Resampling and Reprojecting This week we’ll be working an example with globalTemClim1961-1990.nc. This is Global Temperature climatology from 1961 to 1990. We’ll look at resampling this raster to a different size (resolution). Next, we’ll reproject this dataset. Reprojection and resampling are a frequent task for spatial datasets because the Earth isn’t flat (despite what your distant relative on Facebook might think). Earth’s shape (oblate spheroid) presents challenging projection issues. # load in the packages library(raster) library(rasterVis) library(maptools) # also loads sp package # load in dataset directly via raster package, specify varname which is &#39;tem&#39; for &#39;temperature&#39; temClim = raster(&quot;/Users/james/Documents/Github/geog473-673/datasets/globalTemClim1961-1990.nc&quot;, varname = &#39;tem&#39;, band=1) temClim ## class : RasterLayer ## band : 1 (of 12 bands) ## dimensions : 36, 72, 2592 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ## source : /Users/james/Documents/Github/geog473-673/datasets/globalTemClim1961-1990.nc ## names : CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology ## z-value : 1 ## zvar : tem # Create a new, blank raster that has a totally different sizing newRaster = raster(nrow = 180, ncol = 360) newRaster ## class : RasterLayer ## dimensions : 180, 360, 64800 (nrow, ncol, ncell) ## resolution : 1, 1 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 #resample the temClim raster to the resizedRaster resTemClim = resample(x=temClim, y=newRaster, method=&#39;bilinear&#39;) # can be set to nearest neighbor using &#39;ngb&#39; method resTemClim ## class : RasterLayer ## dimensions : 180, 360, 64800 (nrow, ncol, ncell) ## resolution : 1, 1 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology ## values : -48.8, 32 (min, max) #define new projection as robinson via a proj4 string. Note that this can also be achieved # using EPSG codes with the following - &quot;+init=epsg:4326&quot; for longlat newproj &lt;- CRS(&quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs&quot; ) newproj ## CRS arguments: ## +proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m ## +no_defs +towgs84=0,0,0 # reproject the raster to the new projection projTemClim = projectRaster(resTemClim,crs=newproj) projTemClim ## class : RasterLayer ## dimensions : 171, 372, 63612 (nrow, ncol, ncell) ## resolution : 94500, 107000 (x, y) ## extent : -17570274, 17583726, -9136845, 9160155 (xmin, xmax, ymin, ymax) ## crs : +proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs +towgs84=0,0,0 ## source : memory ## names : CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology ## values : -48.15073, 31.77627 (min, max) data(wrld_simpl) plt &lt;- levelplot(resTemClim, margin=F, par.settings=BuRdTheme, main=&quot;January Global Average Temp 1961-1990&quot;) plt + layer(sp.lines(wrld_simpl, col=&#39;black&#39;, lwd=0.4)) # convert the wrld_simpl land polygons to the robinson projection wrld_simpl = spTransform(wrld_simpl, CRS(&quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs&quot; )) plt &lt;- levelplot(projTemClim, margin=F, par.settings=BuRdTheme, main=&quot;January Global Average Temp 1961-1990&quot;) plt + layer(sp.lines(wrld_simpl, col=&#39;black&#39;, lwd=0.4)) 9.3 PNGs The png() function is a function that saves a plot to png. After we invoke the function and fill out the arguments, we need to execute the plot code between the png() function and dev.off(). dev.off() tells R that you’re done adding things to the plot and that it can be done plotting. png(filename = &quot;~/Downloads/myPNG.png&quot;, width = 10, height = 6, units = &#39;in&#39;,res=100) plt &lt;- levelplot(projTemClim, margin=F, par.settings=BuRdTheme, main=&quot;January Global Average Temp 1961-1990&quot;) plt + layer(sp.lines(wrld_simpl, col=&#39;black&#39;, lwd=0.4)) dev.off() 9.4 Writing Rasters writeRaster(x=projTemClim, filename=&quot;~/Downloads/projectedTemClim1961-1990.tif&quot;, format=&#39;GTiff&#39;, varname=&quot;Temperature&quot;, longname=&quot;Global Average Temperature January 1960-1990&quot;, xname=&quot;lon&quot;, yname=&quot;lat&quot;) You can save these rasters in a variety of formats. If you’re interested in looking them up, run help(writeRaster) and read about the format argument. 9.5 Assignment Load in globalTemClim1961-1990.nc Extract data for January and July Find difference between two months globally Enhance resolution 2x using nearest neighbor method (hint: run help(resample) if you get stuck) Plot in mollwide projection (“+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs”) Write raster to NetCDF Upload PNG and netCDF file to Canvas under week 5 assignment "]
]
