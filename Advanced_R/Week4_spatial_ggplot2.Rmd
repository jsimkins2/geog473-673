# Spatial Data with ggplot2

```{r, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("../documents/images/ggplot2.jpeg")  
```

In Geospatial Sciences we're constantly working with spatial datasets that come in many different projections. We've previously shown how R can be used to read in spatial data, reproject spatial data, and resample spatial datasets. Once a spatial dataset can be stored in R as a data frame, we can use `ggplot` to plot it. 

## Simple Features

One package useful for spatial data in R is the `sf` package (short for simple features). It contains functions that perform equations that place uneven projections on a 2 dimensional computer screen. It can handle many projections and is built to work seamlessly with `ggplot`. For sample data, we're also going to load `ozmaps` which contains maps of Australia.

```{r}
library(ozmaps)
library(sf)

oz_states <- ozmaps::ozmap_states
oz_states
```

`oz_states` is a simple feature which stores data like data frames but has a projection (proj4string), spatial extents, and polygon geometry. In other words, we have shapes on a map that are georeferenced and stored within a data frame that `ggplot` is great at working with. So, let's plot these polygons!

```{r}
ggplot(oz_states) + 
  geom_sf() + 
  coord_sf()

ggplot() + 
  geom_sf(data = oz_states, mapping = aes(fill = NAME), show.legend = FALSE) +
  coord_sf()
```


## Raster to Data Frame

When it comes to spatial data, the `raster` package is our go-to library. After the data is translated to a dataframe and ready to plot, we'll need the help of a package called `mapproj` which makes sense of some external maps that `ggplot2` uses.

```{r}
library(ggplot2)
library(mapproj)
library(maptools) # also loads sp package
library(raster)
library(rasterVis)
library(RColorBrewer)
sstRast <- raster("/Users/james/Documents/Github/geog473-673/datasets/GOES_R_ROLLING_1DAY_20190814.nc")
# crop the raster so this runs faster
sstRast <- crop(sstRast, extent(-100,-80,16,30))
sstRast

# convert to dataframe and 
df <- as.data.frame(sstRast, xy = TRUE) 
# plot the raster
ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = Sea.Surface.Temperature)) + 
  coord_sf(crs=crs(sstRast))
ggplot(data = df) +
    geom_sf(mapping =  aes(x = x, y = y)) + 
    coord_sf(crs = "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")
```

The main new function here is `coord_quickmap()`. It gives the x/y values a geospatial domain. Here's what it looks like:

`coord_quickmap(xlim = NULL, ylim = NULL, expand = TRUE,
  clip = "on")`
  
It's derived from `coord_map` which looks like this:

`coord_map(projection = "mercator", ..., parameters = NULL,
  orientation = NULL, xlim = NULL, ylim = NULL, clip = "on")`

We can see that `coord_map`, 
```{r}
# now let's use a better colorscheme
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = Sea.Surface.Temperature)) + 
  scale_fill_gradientn(colors = jet.colors(7), limits = c(28, 33)) + 
  coord_quickmap()

# now let's add borders
ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = Sea.Surface.Temperature)) + 
  scale_fill_gradientn(colors = jet.colors(7), limits = c(28, 33)) + 
  borders(fill="white", xlim = c(-100,-80), ylim=c(16,30),alpha = 0.5) +
  coord_quickmap(xlim = c(-100,-80), ylim=c(16,30))
```

Notice in the final map how I set xlimits and ylimits in the `coord_quickmap` function. This is the same as we did before with `ggplot2` and `coord_cartesian`. Now that we have lat/lon coordinates, we need to specifiy that "zoom in" boundary with `coord_quickmap`. 

Let's get rid of the expanded area beyond the raster domain using the `expand=FALSE` argument in `coord_quickmap()`

```{r}

# levelplot the sstRast
# USA shapefiles via the getData function
usa <- getData('GADM', country = 'USA', level = 1)

ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = Sea.Surface.Temperature)) + 
  scale_fill_gradientn(colors = jet.colors(7), limits = c(28, 33)) + 
  borders(fill="white", xlim = c(-100,-80), ylim=c(16,30),alpha = 0.5) +
  coord_quickmap(xlim = c(-100,-80), ylim=c(16,30),expand = FALSE)
```

What are some other colors we could use?
```{r,fig.width=8, fig.height=14}
library(RColorBrewer)
display.brewer.all()
```

Let's plot using new colors and a white NA value

```{r}
cols <- brewer.pal(9, "YlOrRd")# nmaximum for palette YlOrRd is 9
pal <- colorRampPalette(cols)

ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = Sea.Surface.Temperature)) + 
  scale_fill_gradientn(colors = pal(20), limits = c(25, 35),na.value = "white") + 
  borders(fill="white", xlim = c(-100,-80), ylim=c(16,30),alpha = 0.5) +
  coord_quickmap(xlim = c(-100,-80), ylim=c(16,30),expand = FALSE)    

```

### Quick tutorial - Multi Plot with ggplot2

Multiple Plots in one window is possible with ggplot2 but is done with a different method. Remember how we named different ggplot2 instances in the previous tutorial? We must do that again in order to achieve the results we want. 

```{r}
library(ggplot2)
library(grid)
library(gridExtra)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

p1 = ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database")

p2 = ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="green", size=5) + 
    geom_point(col="black", size=3) + 
    geom_smooth(method="lm", col="orange") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database")

grid.arrange(p1,p2, ncol=1, nrow=2)
```

We give our 2 plots (or however many plots we have) and tell `grid.arrange()` how many rows and columns we want. Let's say we wanted to show the plots this way...

```{r}
library(ggplot2)
library(grid)
library(gridExtra)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

p1 = ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database")

p2 = ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="green", size=5) + 
    geom_point(col="black", size=3) + 
    geom_smooth(method="lm", col="orange") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database")

grid.arrange(p1,p2, ncol=1, nrow=3)
```

Notice how it left the 3rd row empty because we only provided 2 plots (p1 and p2).

#Assignment:

1. Download treecov.nc from the datasets folder

2. Plot tree cover variable using ggplot2 and with green colortheme for both South America and Africa. Add coastlines.

3. Place each ggplot next to each other in one plot window. 

4. Submit resulting image to Canvas assignment 4



Your final product should look something like...

```{r,echo=FALSE, fig.width=14, fig.height=14}
library(ggplot2)
library(grid)
library(gridExtra)
library(maptools) # also loads sp package
library(raster)
library(rasterVis)
library(RColorBrewer)

treeRast <- raster("/Users/james/Documents/Github/geog473-673/datasets/treecov.nc")
df <- as.data.frame(treeRast, xy = TRUE) 
cols <- brewer.pal(9, "Greens")# nmaximum for palette YlOrRd is 9
pal <- colorRampPalette(cols)

g1 = ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = treecov)) + 
  scale_fill_gradientn(colors = pal(20), limits = c(0, 100), na.value = "white") + 
  borders(colour='black') + 
  coord_quickmap(xlim = c(-100,-30), ylim=c(-60,20),expand = FALSE) +
  labs(title="South America Tree Cover %", y="Latitude", x="Longitude")

g2 = ggplot() +
  geom_raster(data = df , aes(x = x, y = y, fill = treecov)) + 
  scale_fill_gradientn(colors = pal(20), limits = c(0, 100), na.value = "white") + 
  borders(colour='black') + 
  coord_quickmap(xlim = c(-20,60), ylim=c(-40,40),expand = FALSE) +
  labs(title="Africa Tree Cover %", y="Latitude", x="Longitude")


grid.arrange(g1,g2, ncol=2, nrow=1)
```


## Extra Credit - 2 Points

Using the data above, approximate the average tree cover for South America and Africa (extents don't have to be exact, just generally)

1) Plot the same domains above but this time color each continent (yes, the whole thing) based on the average tree cover. For example, if one of the continent has an average tree cover of 30%, the entire continent would be red based on the colorscale you choose where 30% is red. 

2) Submit plot and code to canvas 